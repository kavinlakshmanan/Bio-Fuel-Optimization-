# -*- coding: utf-8 -*-
"""Optimization_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r701f0_AZsq52yWd2ZVRQA3hfYA7Zn8u

# IMPORT LIBRAIRES
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""# Import Dataset"""

df = pd.read_csv("/content/ANN(bio-fuel).csv")
df

"""# Data Exploration"""

df.describe()

df.columns

df.dtypes

"""# Check for Null Values"""

d=df.drop(16)
d.shape

df.isnull().sum()

"""# Plotting Values

## Injection Timing
"""

color1 = ['#FF0000', '#00FF00', '#FFA500']

color2 = ['#FFE6E6', '#E1AFD1', '#AD88C6']

sns.barplot(data=df, x='IT °bTDC', y='BSFC (kg/kWh)',hue ='IP (bar)',palette=color2)
plt.title('IT vs BSFC')
plt.xlabel('Injection Timing (°bTDC)')
plt.ylabel('BSFC (kg/kWh)')

sns.barplot(data=df, x='IT °bTDC', y='BTE (%)',hue ='IP (bar)', palette=color2)
plt.title('IT vs BTE (%)')
plt.xlabel('Injection Timing (°bTDC)')
plt.ylabel('BTE (%)')

sns.barplot(data=df, x='IT °bTDC', y='CO (%)',hue ='IP (bar)', palette=color2)
plt.title('IT vs CO (%)')
plt.xlabel('Injection Timing (°bTDC)')
plt.ylabel('CO (%)')

sns.barplot(data=df, x='IT °bTDC', y='HC (ppm)',hue ='IP (bar)',palette=color2)
plt.title('IT vs HC (ppm)')
plt.xlabel('Injection Timing (°bTDC)')
plt.ylabel('HC (ppm)')

sns.barplot(data=df, x='IT °bTDC', y='NOx (ppm)',hue="IP (bar)", palette=color2)
plt.title('IT vs NOx (ppm)')
plt.xlabel('Injection Timing (°bTDC)')
plt.ylabel('NOx (ppm)')

sns.barplot(data=df, x='IT °bTDC', y='Smoke (Opacity)',hue ='IP (bar)', palette=color2)
plt.title('IT vs Smoke (Opacity)')
plt.xlabel('Injection Timing (°bTDC)')
plt.ylabel('Smoke (Opacity)')

"""## Injection Pressure"""

sns.barplot(data=df, x='IP (bar)', y='Smoke (Opacity)',hue ='IT °bTDC', palette=color1)
plt.title('IP(bar) vs Smoke (Opacity)')
plt.xlabel('Injection Pressure(bar)')
plt.ylabel('Smoke (Opacity)')

sns.barplot(data=df, x='IP (bar)', y='BSFC (kg/kWh)',hue ='IT °bTDC', palette=color1)
plt.title('IP(bar) vs BSFC (kg/kWh)')
plt.xlabel('Injection Pressure(bar)')
plt.ylabel('BSFC (kg/kWh)')

sns.barplot(data=df, x='IP (bar)', y='BTE (%)',hue ='IT °bTDC', palette=color1)
plt.title('IP(bar) vs BTE (%)')
plt.xlabel('Injection Pressure(bar)')
plt.ylabel('BTE (%)')

sns.barplot(data=df, x='IP (bar)', y='CO (%)',hue ='IT °bTDC', palette=color1)
plt.title('IP(bar) vs CO (%)')
plt.xlabel('Injection Pressure(bar)')
plt.ylabel('CO (%)')

sns.barplot(data=df, x='IP (bar)', y='HC (ppm)',hue ='IT °bTDC', palette=color1)
plt.title('IP(bar) vs HC (ppm)')
plt.xlabel('Injection Pressure(bar)')
plt.ylabel('HC (ppm)')

sns.barplot(data=df, x='IP (bar)', y='NOx (ppm)',hue ='IT °bTDC', palette=color1)
plt.title('IP(bar) vs NOx (ppm)')
plt.xlabel('Injection Pressure(bar)')
plt.ylabel('NOx (ppm)')

"""## EGR"""

sns.barplot(data=df, x='EGR (%)', y='BSFC (kg/kWh)',hue ='IP (bar)', palette="GnBu_d")
plt.title('EGR (%) vs BSFC (kg/kWh)')
plt.xlabel('EGR (%)')
plt.ylabel('BSFC (kg/kWh)')

sns.barplot(data=df, x='EGR (%)', y='BTE (%)',hue ='IP (bar)', palette="GnBu_d")
plt.title('EGR (%) vs BTE (%)')
plt.xlabel('EGR (%)')
plt.ylabel('BTE (%)')

sns.barplot(data=df, x='EGR (%)', y='CO (%)',hue ='IP (bar)', palette="GnBu_d")
plt.title('EGR (%) vs CO (%)')
plt.ylabel('CO (%)')

sns.barplot(data=df, x='EGR (%)', y='HC (ppm)',hue ='IP (bar)', palette="GnBu_d")
plt.title('EGR (%) vs HC (ppm)')
plt.xlabel('EGR (%)')
plt.ylabel('HC (ppm)')

sns.barplot(data=df, x='EGR (%)', y='NOx (ppm)',hue ='IP (bar)', palette="GnBu_d")
plt.title('EGR (%) vs NOx (ppm)')
plt.xlabel('EGR (%)')
plt.ylabel('NOx (ppm)')

sns.barplot(data=df, x='EGR (%)', y='Smoke (Opacity)',hue ='IP (bar)', palette="GnBu_d")
plt.title('EGR (%) vs Smoke (Opacity)')
plt.xlabel('EGR (%)')
plt.ylabel('Smoke (Opacity)')

"""# Optimization"""

# Define the optimization criteria weights (negative for minimization, positive for maximization)
weights = {
    "BSFC (kg/kWh)": -1,
    "BTE (%)": 1,
    "CO (%)": -1,
    "HC (ppm)": -1,
    "NOx (ppm)": -1,
    "Smoke (Opacity)": -1
}

# Calculate the score for each row
df["Score"] = df[list(weights.keys())].mul(list(weights.values())).sum(axis=1)

"""# Most Optimum Reading"""

# Find the row with the highest score
highest_optimized_reading = df.loc[df["Score"].idxmax()]

print("highest_Optimized Reading:")
highest_optimized_reading

# Column with highest optimum reading
clo_no1=df["Score"].idxmax()
print("highest optimum reading:" ,clo_no1)

"""# Least Optimum Reading"""

# Find the row with the lowest score
least_optimized_reading = df.loc[df["Score"].idxmin()]

print("Least Optimized Reading:")
least_optimized_reading

# Column with least optimum reading
clo_no2=df["Score"].idxmin()
print("least optimum reading:" ,clo_no2)

"""# Notes"""

#  Define the optimization criteria. Based on the given factors, you might want to minimize BSFC, CO, HC, NOx, and Smoke Opacity, and maximize BTE.

#  Calculate a score for each row based on the optimization criteria.

#  Identify the row with the highest score as the optimized reading.

"""# ANN Prediction"""

# Importing necessary libraries
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
import tensorflow as tf
from tensorflow import keras
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Step 1: Data-processing
data = pd.read_csv("/content/ANN(bio-fuel).csv")

# Step 2:Normalize or standardize the input features
scaler = StandardScaler()
scaled_data = scaler.fit_transform(data.drop(columns=['BSFC (kg/kWh)', 'BTE (%)', 'CO (%)',
       'HC (ppm)', 'NOx (ppm)', 'Smoke (Opacity)']))

# Step 3: Data Splitting
x = scaled_data  # Assuming scaled_data contains the features
y = data[['BSFC (kg/kWh)', 'BTE (%)', 'CO (%)', 'HC (ppm)', 'NOx (ppm)', 'Smoke (Opacity)']]
X_train, X_test, y_train, y_test = train_test_split(x,y, test_size=0.2, random_state=42)

# Step 4: ANN Architecture Design
model = keras.Sequential([
    keras.layers.Dense(3, activation='relu', input_shape=(3,)),
    keras.layers.Dense(8, activation='relu'),
    keras.layers.Dense(8, activation='relu'),
    keras.layers.Dense(6)  # Output layer with 6 neurons
])
model.summary()

# Step 5:Training the ANN
model.compile(optimizer='adam', loss='mean_squared_error',metrics=['accuracy'])
history = model.fit(X_train, y_train, epochs=10, validation_split=0.2, verbose=0)

# Step 6:Testing
y_pred = model.predict(X_test)

# Step 7:Performance Metrics
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error:", mse)

input = ['IP (bar)', 'IT °bTDC', 'EGR (%)']
output = ['BSFC (kg/kWh)', 'BTE (%)', 'CO (%)','HC (ppm)','NOx (ppm)','Smoke (Opacity)']

x = d[input].values
y = d[output].values

plt.scatter(y_train[:,1],y_test[:,1])
plt.figure(figsize=(10, 6))
plt.show()

"""# New Section"""

# Scatter plot
plt.scatter(y_train[:,0], y_test[:,0], label='BSFC (kg/kWh)')

# Add regression line
coefficients = np.polyfit(y_train[:,1], y_test[:,], 1)  # Fit a first-degree polynomial (linear regression)
regression_line = np.poly1d(coefficients)
plt.plot(y_train[:,], regression_line(y_train[:,]), color='red', label='Regression Line')

# Add labels and legend
plt.xlabel('BSFC (kg/kWh) Actual')
plt.ylabel('BSFC (kg/kWh) Predicted')
plt.legend()

# Show plot
plt.show()

plt.scatter(y_train[:,5],y_test[:,5],label='Smoke (Opacity)')
plt.plot(y_test[:,5],y_test[:,5],'r',linewidth='3',label='Regression Line')

# Add labels and legend
plt.xlabel('Smoke (Opacity) Actual')
plt.ylabel('Smoke (Opacity) Predicted')
plt.legend()

# Show plot
plt.show()

"""# Structure of the ANN Network"""

from tensorflow.keras.utils import plot_model

# Assuming 'model' is your trained neural network model
# Define the file path to save the image of the neural network architecture
image_path = "neural_network_architecture.png"

# Plot and save the image of the neural network architecture
plot_model(model, to_file=image_path, show_shapes=True, show_layer_names=True)

# Display the image
from PIL import Image
img = Image.open(image_path)
img.show()

!pip install graphviz

class Neuron():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def draw(self, neuron_radius):
        circle = pyplot.Circle((self.x, self.y), radius=neuron_radius, fill=False)
        pyplot.gca().add_patch(circle)


class Layer():
    def __init__(self, network, number_of_neurons, number_of_neurons_in_widest_layer):
        self.vertical_distance_between_layers = 6
        self.horizontal_distance_between_neurons = 2
        self.neuron_radius = 0.5
        self.number_of_neurons_in_widest_layer = number_of_neurons_in_widest_layer
        self.previous_layer = self.__get_previous_layer(network)
        self.y = self.__calculate_layer_y_position()
        self.neurons = self.__intialise_neurons(number_of_neurons)

    def __intialise_neurons(self, number_of_neurons):
        neurons = []
        x = self.__calculate_left_margin_so_layer_is_centered(number_of_neurons)
        for iteration in range(number_of_neurons):
            neuron = Neuron(x, self.y)
            neurons.append(neuron)
            x += self.horizontal_distance_between_neurons
        return neurons

    def __calculate_left_margin_so_layer_is_centered(self, number_of_neurons):
        return self.horizontal_distance_between_neurons * (self.number_of_neurons_in_widest_layer - number_of_neurons) / 2

    def __calculate_layer_y_position(self):
        if self.previous_layer:
            return self.previous_layer.y + self.vertical_distance_between_layers
        else:
            return 0

    def __get_previous_layer(self, network):
        if len(network.layers) > 0:
            return network.layers[-1]
        else:
            return None

    def __line_between_two_neurons(self, neuron1, neuron2):
        angle = atan((neuron2.x - neuron1.x) / float(neuron2.y - neuron1.y))
        x_adjustment = self.neuron_radius * sin(angle)
        y_adjustment = self.neuron_radius * cos(angle)
        line = pyplot.Line2D((neuron1.x - x_adjustment, neuron2.x + x_adjustment), (neuron1.y - y_adjustment, neuron2.y + y_adjustment))
        pyplot.gca().add_line(line)

    def draw(self, layerType=0):
        for neuron in self.neurons:
            neuron.draw( self.neuron_radius )
            if self.previous_layer:
                for previous_layer_neuron in self.previous_layer.neurons:
                    self.__line_between_two_neurons(neuron, previous_layer_neuron)
        # write Text
        x_text = self.number_of_neurons_in_widest_layer * self.horizontal_distance_between_neurons
        if layerType == 0:
            pyplot.text(x_text, self.y, 'Input Layer', fontsize = 12)
        elif layerType == -1:
            pyplot.text(x_text, self.y, 'Output Layer', fontsize = 12)
        else:
            pyplot.text(x_text, self.y, 'Hidden Layer '+str(layerType), fontsize = 12)

class NeuralNetwork():
    def __init__(self, number_of_neurons_in_widest_layer):
        self.number_of_neurons_in_widest_layer = number_of_neurons_in_widest_layer
        self.layers = []
        self.layertype = 0

    def add_layer(self, number_of_neurons ):
        layer = Layer(self, number_of_neurons, self.number_of_neurons_in_widest_layer)
        self.layers.append(layer)

    def draw(self):
        pyplot.figure()
        for i in range( len(self.layers) ):
            layer = self.layers[i]
            if i == len(self.layers)-1:
                i = -1
            layer.draw( i )
        pyplot.axis('scaled')
        pyplot.axis('off')
        pyplot.title( 'Neural Network architecture', fontsize=15 )
        pyplot.show()

class DrawNN():
    def __init__( self, neural_network ):
        self.neural_network = neural_network

    def draw( self ):
        widest_layer = max( self.neural_network )
        network = NeuralNetwork( widest_layer )
        for l in self.neural_network:
            network.add_layer(l)
        network.draw()

# Define the neural network architecture
neural_network_architecture = [3, 8, 8, 6]

# Instantiate the DrawNN class with the neural network architecture
network = DrawNN(neural_network_architecture)

# Generate and display the neural network visualization
network.draw()

